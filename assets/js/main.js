console.log('This site was generated by Hugo.');

document.addEventListener('DOMContentLoaded', () => {
  const upvoteContainers = Array.from(document.querySelectorAll('[data-upvote]'));
  if (upvoteContainers.length) {
    const hasMoved = { value: false };
    const started = Date.now();
    const movementHandler = () => { hasMoved.value = true; };
    document.addEventListener('mousemove', movementHandler, { once: true });
    document.addEventListener('touchmove', movementHandler, { once: true });

    upvoteContainers.forEach((container) => {
      const slug = container.getAttribute('data-slug');
      const endpoint = container.getAttribute('data-endpoint');
      const infoEndpoint = container.getAttribute('data-info-endpoint');
      const form = container.querySelector('form');
      const button = container.querySelector('.upvote-button');
      const countEl = container.querySelector('.upvote-count');
      if (!slug || !endpoint || !infoEndpoint || !form || !button || !countEl) {
        return;
      }

      const updateState = ({ upvote_count, upvoted }) => {
        if (typeof upvote_count === 'number') {
          countEl.textContent = upvote_count.toString();
          button.classList.remove('upvote-button--cool', 'upvote-button--warm', 'upvote-button--hot');
          if (upvote_count >= 100) {
            button.classList.add('upvote-button--hot');
          } else if (upvote_count >= 10) {
            button.classList.add('upvote-button--warm');
          } else {
            button.classList.add('upvote-button--cool');
          }
        }
        if (upvoted) {
          button.disabled = true;
          button.classList.add('upvote-button--active');
          button.title = 'Toasted';
        }
      };

      fetch(`${infoEndpoint}?slug=${encodeURIComponent(slug)}`, { credentials: 'include' })
        .then((resp) => resp.ok ? resp.json() : null)
        .then((data) => {
          if (!data) return;
          updateState(data);
        })
        .catch(() => {});

      form.addEventListener('submit', (e) => {
        e.preventDefault();
        if (button.disabled) return;
        if (!hasMoved.value || Date.now() - started < 2000) return;

        fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ slug }),
          credentials: 'include'
        })
          .then((resp) => resp.ok ? resp.json() : null)
          .then((data) => {
            if (!data) return;
            updateState(data);
            if (typeof data.upvote_count === 'number') {
              countEl.textContent = data.upvote_count.toString();
            } else {
              const current = parseInt(countEl.textContent || '0', 10) || 0;
              countEl.textContent = String(current + 1);
            }
          })
          .catch(() => {});
      });
    });
  }
  // Mobile nav toggle
  const navToggleBtn = document.querySelector('[data-nav-toggle]');
  const navEl = document.querySelector('[data-nav]');
  if (navToggleBtn && navEl) {
    navToggleBtn.addEventListener('click', () => {
      const open = navEl.classList.toggle('is-open');
      navToggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
    });
  }

  const toc = document.querySelector('.toc-dropdown');
  if (toc) {
    toc.addEventListener('click', (e) => {
      const target = e.target;
      if (target && target.tagName === 'A') {
        toc.open = false;
      }
    });
  }

  // Archive search wiring
  const searchInput = document.getElementById('archive-search');
  const groupsEl = document.getElementById('archive-groups');
  const resultsEl = document.getElementById('archive-results');
  if (searchInput && resultsEl) {
    let fuseInstance = null;
    let indexData = null;

    const escapeHtml = (value) => String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

    const collectMatchedLines = ({ item, matches }, query) => {
      const lines = new Set();

      const safeQuery = String(query || '').trim().toLowerCase();
      const queryTerms = safeQuery.length ? safeQuery.split(/\s+/).filter(Boolean) : [];

      const normalizeSnippetLine = (line) => {
        let out = String(line || '').trim();
        if (!out) return '';
        if (out === '```') return '';
        out = out
          .replace(/^#{1,6}\s+/, '')
          .replace(/^\s*([-*+]|\d+\.)\s+/, '')
          .replace(/^>\s+/, '')
          .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1')
          .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
          .replace(/`([^`]+)`/g, '$1')
          .trim();
        return out;
      };

      const raw = typeof item.raw === 'string' ? item.raw.replace(/\r\n/g, '\n') : '';
      const content = typeof item.content === 'string' ? item.content.replace(/\r\n/g, '\n') : '';
      const summary = typeof item.summary === 'string' ? item.summary.replace(/\r\n/g, '\n') : '';

      if (raw && queryTerms.length) {
        raw.split('\n').forEach((line) => {
          const cleaned = normalizeSnippetLine(line);
          if (!cleaned) return;
          const lower = cleaned.toLowerCase();
          const matchesPhrase = safeQuery.length ? lower.includes(safeQuery) : false;
          const matchesTerms = queryTerms.length ? queryTerms.every((term) => lower.includes(term)) : false;
          if (matchesPhrase || matchesTerms) {
            lines.add(cleaned);
          }
        });
      }

      const matchArr = Array.isArray(matches) ? matches : [];
      const contentMatches = matchArr.filter((m) => m && m.key === 'content' && Array.isArray(m.indices));

      contentMatches.forEach((m) => {
        const value = typeof m.value === 'string' ? m.value.replace(/\r\n/g, '\n') : content;
        if (!value) return;
        m.indices.forEach((pair) => {
          if (!Array.isArray(pair) || pair.length < 2) return;
          const startIndex = pair[0];
          const endIndex = pair[1];
          if (typeof startIndex !== 'number' || typeof endIndex !== 'number') return;
          const lineStartIdx = value.lastIndexOf('\n', startIndex);
          const lineStart = lineStartIdx === -1 ? 0 : lineStartIdx + 1;
          const lineEndIdx = value.indexOf('\n', endIndex + 1);
          const lineEnd = lineEndIdx === -1 ? value.length : lineEndIdx;
          const line = normalizeSnippetLine(value.slice(lineStart, lineEnd));
          if (line) lines.add(line);
        });
      });

      if (lines.size === 0 && content && queryTerms.length) {
        content.split(/\n+/).forEach((line) => {
          const trimmed = normalizeSnippetLine(line);
          if (!trimmed) return;
          const lower = trimmed.toLowerCase();
          if (queryTerms.every((term) => lower.includes(term))) {
            lines.add(trimmed);
          }
        });
      }

      if (lines.size === 0 && summary && queryTerms.length) {
        summary.split(/\n+/).forEach((line) => {
          const trimmed = normalizeSnippetLine(line);
          if (!trimmed) return;
          const lower = trimmed.toLowerCase();
          if (queryTerms.every((term) => lower.includes(term))) {
            lines.add(trimmed);
          }
        });
      }

      return Array.from(lines);
    };

    const renderResults = (items, query) => {
      if (!Array.isArray(items)) return;
      if (items.length === 0) {
        resultsEl.innerHTML = '<p class="text-[var(--color-muted)]">No results</p>';
        return;
      }

      const normalized = items.map((r) => ({
        item: r && r.item ? r.item : r,
        matches: r && Array.isArray(r.matches) ? r.matches : []
      })).filter((x) => x.item);

      const grouped = new Map();
      normalized.forEach((r) => {
        const year = r.item.year || (typeof r.item.dateISO === 'string' ? r.item.dateISO.slice(0, 4) : '');
        if (!grouped.has(year)) grouped.set(year, []);
        grouped.get(year).push(r);
      });

      const years = Array.from(grouped.keys())
        .filter(Boolean)
        .sort((a, b) => (Number(b) || 0) - (Number(a) || 0));

      const groupHtml = years.map((year) => {
        const groupItems = grouped.get(year) || [];
        groupItems.sort((a, b) => String(b.item.dateISO || '').localeCompare(String(a.item.dateISO || '')));

        const itemsHtml = groupItems.map((r) => {
          const title = r.item.title || '';
          const dateShort = r.item.dateShort || r.item.date || '';
          const dateISO = r.item.dateISO || '';
          const link = r.item.permalink || '#';
          const matchedLines = collectMatchedLines(r, query);

          const snippetHtml = matchedLines.length
            ? `
              <div class="flex gap-4 mt-1">
                <span aria-hidden="true" class="text-sm text-[var(--color-muted)] font-mono shrink-0 opacity-0">${escapeHtml(dateShort)}</span>
                <div>
                  ${matchedLines.map((line) => `<p class="text-sm text-[var(--color-muted)] font-mono break-all">${escapeHtml(line)}</p>`).join('')}
                </div>
              </div>
            `
            : '';

          return `
            <li>
              <div class="flex gap-4 items-baseline">
                <time class="text-sm text-[var(--color-muted)] font-mono shrink-0" datetime="${escapeHtml(dateISO)}">
                  ${escapeHtml(dateShort)}
                </time>
                <a href="${escapeHtml(link)}" class="hover:text-[var(--color-accent)] transition-colors truncate">
                  ${escapeHtml(title)}
                </a>
              </div>
              ${snippetHtml}
            </li>
          `;
        }).join('');

        return `
          <div class="mb-8">
            <h2 class="text-xl font-semibold mb-4 text-[var(--color-muted)]">${escapeHtml(year)}</h2>
            <ul class="space-y-2">
              ${itemsHtml}
            </ul>
          </div>
        `;
      }).join('');

      resultsEl.innerHTML = groupHtml;
    };

    const showGroups = () => {
      if (groupsEl) groupsEl.hidden = false;
      resultsEl.hidden = true;
    };
    const showResults = () => {
      if (groupsEl) groupsEl.hidden = true;
      resultsEl.hidden = false;
    };

    // Make search accessible
    searchInput.setAttribute('aria-label', 'Search posts');
    searchInput.setAttribute('role', 'search');

    const initFuse = async () => {
      if (fuseInstance) return fuseInstance;
      if (!indexData) {
        try {
          const res = await fetch('/index.json', { cache: 'no-store' });
          if (!res.ok) return null;
          indexData = await res.json();
        } catch (e) {
          // Fail silently to avoid breaking page
          return null;
        }
      }
      if (!Array.isArray(indexData)) return null;
      const options = {
        includeScore: true,
        includeMatches: true,
        findAllMatches: true,
        ignoreLocation: true,
        minMatchCharLength: 2,
        threshold: 0.3,
        keys: [
          { name: 'title', weight: 2 },
          { name: 'summary', weight: 1 },
          { name: 'tags', weight: 0.5 },
          { name: 'categories', weight: 0.5 },
          { name: 'content', weight: 0.25 }
        ]
      };
      if (window.Fuse) {
        fuseInstance = new window.Fuse(indexData, options);
      }
      return fuseInstance;
    };

    searchInput.addEventListener('input', async (ev) => {
      const q = (ev.target.value || '').trim();
      if (q.length === 0) {
        showGroups();
        return;
      }
      const fuse = await initFuse();
      if (!fuse) return;
      const results = fuse.search(q).slice(0, 50);
      renderResults(results, q);
      showResults();
    });

    // If homepage hides groups, ensure initial state shows results hidden
    if (!groupsEl) {
      resultsEl.hidden = true;
    }
  }

  // PhotoSwipe lightbox for all images in article content
  (async () => {
    const article = document.querySelector('article.content');
    if (!article) return;

    try {
      // Helper to reliably get intrinsic dimensions; falls back to probing the src
      const getImageDimensions = (src, imgEl) => new Promise((resolve) => {
        const w = (imgEl && imgEl.naturalWidth) || 0;
        const h = (imgEl && imgEl.naturalHeight) || 0;
        if (w > 0 && h > 0) {
          resolve({ width: w, height: h });
          return;
        }
        const probe = new Image();
        probe.onload = () => {
          resolve({
            width: probe.naturalWidth || 1600,
            height: probe.naturalHeight || 900
          });
        };
        probe.onerror = () => resolve({ width: 1600, height: 900 });
        probe.src = src;
      });

      const { default: PhotoSwipeLightbox } = await import('https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe-lightbox.esm.min.js');

      // Primary lightbox for images with data-pswp-width attributes
      const lightbox = new PhotoSwipeLightbox({
        gallery: 'article.content',
        children: 'a[data-pswp-width]',
        wheelToZoom: true,
        pswpModule: () => import('https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe.esm.min.js')
      });
      lightbox.init();

      // Handle all lightbox-image anchors (including those without data-pswp-width)
      const lightboxAnchors = Array.from(article.querySelectorAll('a.lightbox-image:not([data-pswp-width])'))
        .map(a => ({ a, img: a.querySelector('img') }))
        .filter(x => x.img);

      if (lightboxAnchors.length) {
        const { default: LB } = await import('https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe-lightbox.esm.min.js');
        const lbLinks = new LB({
          wheelToZoom: true,
          pswpModule: () => import('https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe.esm.min.js')
        });
        lbLinks.init();
        lightboxAnchors.forEach(({ a, img }) => {
          a.style.cursor = 'zoom-in';
          a.addEventListener('click', async (e) => {
            e.preventDefault();
            const src = a.getAttribute('href');
            const dims = await getImageDimensions(src, img);
            lbLinks.loadAndOpen(0, [{ src, width: dims.width, height: dims.height, alt: img.alt || '' }]);
          });
        });
      }

      // Fallback for images not wrapped by any anchor
      const orphanImgs = Array.from(article.querySelectorAll('img:not(a img)'));
      if (orphanImgs.length) {
        const { default: LB } = await import('https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe-lightbox.esm.min.js');
        const lb = new LB({
          wheelToZoom: true,
          pswpModule: () => import('https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe.esm.min.js')
        });
        lb.init();
        orphanImgs.forEach((img) => {
          img.style.cursor = 'zoom-in';
          img.addEventListener('click', async () => {
            const src = img.currentSrc || img.src;
            const dims = await getImageDimensions(src, img);
            lb.loadAndOpen(0, [{ src, width: dims.width, height: dims.height, alt: img.alt || '' }]);
          });
        });
      }
    } catch (e) {
      // no-op if CDN blocked
    }
  })();

  // Copy-to-clipboard for code blocks
  document.addEventListener('click', async (ev) => {
    const btn = ev.target.closest('[data-copy-code]');
    if (!btn) return;
    const wrapper = btn.closest('.codeblock');
    if (!wrapper) return;
    const pre = wrapper.querySelector('.highlight pre');
    if (!pre) return;
    try {
      const text = pre.textContent || '';
      await navigator.clipboard.writeText(text);
      const original = btn.textContent;
      btn.textContent = 'Copied';
      setTimeout(() => { btn.textContent = original; }, 1200);
    } catch (e) {
      // ignore
    }
  });

  // Word wrap toggle for code blocks
  document.addEventListener('click', (ev) => {
    const btn = ev.target.closest('[data-wrap-toggle]');
    if (!btn) return;
    const wrapper = btn.closest('.codeblock');
    if (!wrapper) return;
    const isWrapped = wrapper.classList.toggle('wrapped');
    btn.textContent = isWrapped ? 'Nowrap' : 'Wrap';
  });
  
  // Theme toggle
  const themeBtn = document.querySelector('[data-theme-toggle]');
  if (themeBtn) {
    const root = document.documentElement;
    const applyTheme = (theme) => {
      root.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
      themeBtn.setAttribute('aria-label', theme === 'dark' ? 'Switch to light theme' : 'Switch to dark theme');
    };
    const current = root.getAttribute('data-theme') || (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    applyTheme(current);
    themeBtn.addEventListener('click', () => {
      const next = root.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      applyTheme(next);
      // Notify listeners (e.g., mermaid re-render)
      try { window.dispatchEvent(new Event('themechange')); } catch (_) {}
    });
  }
});
