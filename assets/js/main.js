console.log('This site was generated by Hugo.');

document.addEventListener('DOMContentLoaded', () => {
  const upvoteContainers = Array.from(document.querySelectorAll('[data-upvote]'));
  if (upvoteContainers.length) {
    const hasMoved = { value: false };
    const started = Date.now();
    const movementHandler = () => { hasMoved.value = true; };
    document.addEventListener('mousemove', movementHandler, { once: true });
    document.addEventListener('touchmove', movementHandler, { once: true });

    upvoteContainers.forEach((container) => {
      const slug = container.getAttribute('data-slug');
      const endpoint = container.getAttribute('data-endpoint');
      const infoEndpoint = container.getAttribute('data-info-endpoint');
      const form = container.querySelector('form');
      const button = container.querySelector('.upvote-button');
      const countEl = container.querySelector('.upvote-count');
      if (!slug || !endpoint || !infoEndpoint || !form || !button || !countEl) {
        return;
      }

      const updateState = ({ upvote_count, upvoted }) => {
        if (typeof upvote_count === 'number') {
          countEl.textContent = upvote_count.toString();
          button.classList.remove('upvote-button--cool', 'upvote-button--warm', 'upvote-button--hot');
          if (upvote_count >= 100) {
            button.classList.add('upvote-button--hot');
          } else if (upvote_count >= 10) {
            button.classList.add('upvote-button--warm');
          } else {
            button.classList.add('upvote-button--cool');
          }
        }
        if (upvoted) {
          button.disabled = true;
          button.classList.add('upvote-button--active');
          button.title = 'Toasted';
        }
      };

      fetch(`${infoEndpoint}?slug=${encodeURIComponent(slug)}`, { credentials: 'include' })
        .then((resp) => resp.ok ? resp.json() : null)
        .then((data) => {
          if (!data) return;
          updateState(data);
        })
        .catch(() => {});

      form.addEventListener('submit', (e) => {
        e.preventDefault();
        if (button.disabled) return;
        if (!hasMoved.value || Date.now() - started < 2000) return;

        fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ slug }),
          credentials: 'include'
        })
          .then((resp) => resp.ok ? resp.json() : null)
          .then((data) => {
            if (!data) return;
            updateState(data);
            if (typeof data.upvote_count === 'number') {
              countEl.textContent = data.upvote_count.toString();
            } else {
              const current = parseInt(countEl.textContent || '0', 10) || 0;
              countEl.textContent = String(current + 1);
            }
          })
          .catch(() => {});
      });
    });
  }
  // Mobile nav toggle
  const navToggleBtn = document.querySelector('[data-nav-toggle]');
  const navEl = document.querySelector('[data-nav]');
  if (navToggleBtn && navEl) {
    navToggleBtn.addEventListener('click', () => {
      const open = navEl.classList.toggle('is-open');
      navToggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
    });
  }

  const toc = document.querySelector('.toc-dropdown');
  if (toc) {
    toc.addEventListener('click', (e) => {
      const target = e.target;
      if (target && target.tagName === 'A') {
        toc.open = false;
      }
    });
  }

  // Archive search wiring
  const searchInput = document.getElementById('archive-search');
  const groupsEl = document.getElementById('archive-groups');
  const resultsEl = document.getElementById('archive-results');
  if (searchInput && resultsEl) {
    let fuseInstance = null;
    let indexData = null;
    const indexUrl = searchInput.getAttribute('data-index-url') || '/index.json';
    const fuseSrc = 'https://cdn.jsdelivr.net/npm/fuse.js@7.0.0';

    const escapeHtml = (value) => String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

    const collectMatchedLines = ({ item, matches }, query) => {
      const lines = new Set();

      const safeQuery = String(query || '').trim().toLowerCase();
      const queryTerms = safeQuery.length ? safeQuery.split(/\s+/).filter(Boolean) : [];

      const normalizeSnippetLine = (line) => {
        let out = String(line || '').trim();
        if (!out) return '';
        if (out === '```') return '';
        out = out
          .replace(/^#{1,6}\s+/, '')
          .replace(/^\s*([-*+]|\d+\.)\s+/, '')
          .replace(/^>\s+/, '')
          .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1')
          .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
          .replace(/`([^`]+)`/g, '$1')
          .trim();
        return out;
      };

      const content = typeof item.content === 'string' ? item.content.replace(/\r\n/g, '\n') : '';
      const summary = typeof item.summary === 'string' ? item.summary.replace(/\r\n/g, '\n') : '';

      const matchArr = Array.isArray(matches) ? matches : [];
      const contentMatches = matchArr.filter((m) => m && m.key === 'content' && Array.isArray(m.indices));

      contentMatches.forEach((m) => {
        const value = typeof m.value === 'string' ? m.value.replace(/\r\n/g, '\n') : content;
        if (!value) return;
        m.indices.forEach((pair) => {
          if (!Array.isArray(pair) || pair.length < 2) return;
          const startIndex = pair[0];
          const endIndex = pair[1];
          if (typeof startIndex !== 'number' || typeof endIndex !== 'number') return;
          const lineStartIdx = value.lastIndexOf('\n', startIndex);
          const lineStart = lineStartIdx === -1 ? 0 : lineStartIdx + 1;
          const lineEndIdx = value.indexOf('\n', endIndex + 1);
          const lineEnd = lineEndIdx === -1 ? value.length : lineEndIdx;
          const line = normalizeSnippetLine(value.slice(lineStart, lineEnd));
          if (line) lines.add(line);
        });
      });

      if (lines.size === 0 && content && queryTerms.length) {
        content.split(/\n+/).forEach((line) => {
          const trimmed = normalizeSnippetLine(line);
          if (!trimmed) return;
          const lower = trimmed.toLowerCase();
          if (queryTerms.every((term) => lower.includes(term))) {
            lines.add(trimmed);
          }
        });
      }

      if (lines.size === 0 && summary && queryTerms.length) {
        summary.split(/\n+/).forEach((line) => {
          const trimmed = normalizeSnippetLine(line);
          if (!trimmed) return;
          const lower = trimmed.toLowerCase();
          if (queryTerms.every((term) => lower.includes(term))) {
            lines.add(trimmed);
          }
        });
      }

      return Array.from(lines);
    };

    const renderResults = (items, query) => {
      if (!Array.isArray(items)) return;
      if (items.length === 0) {
        resultsEl.innerHTML = '<p class="text-[var(--color-muted)]">No results</p>';
        return;
      }

      const normalized = items.map((r) => ({
        item: r && r.item ? r.item : r,
        matches: r && Array.isArray(r.matches) ? r.matches : []
      })).filter((x) => x.item);

      const grouped = new Map();
      normalized.forEach((r) => {
        const year = r.item.year || (typeof r.item.dateISO === 'string' ? r.item.dateISO.slice(0, 4) : '');
        if (!grouped.has(year)) grouped.set(year, []);
        grouped.get(year).push(r);
      });

      const years = Array.from(grouped.keys())
        .filter(Boolean)
        .sort((a, b) => (Number(b) || 0) - (Number(a) || 0));

      const groupHtml = years.map((year) => {
        const groupItems = grouped.get(year) || [];
        groupItems.sort((a, b) => String(b.item.dateISO || '').localeCompare(String(a.item.dateISO || '')));

        const itemsHtml = groupItems.map((r) => {
          const title = r.item.title || '';
          const dateShort = r.item.dateShort || r.item.date || '';
          const dateISO = r.item.dateISO || '';
          const link = r.item.permalink || '#';
          const matchedLines = collectMatchedLines(r, query);

          const snippetHtml = matchedLines.length
            ? `
              <div class="flex gap-4 mt-1">
                <span aria-hidden="true" class="text-sm text-[var(--color-muted)] font-mono shrink-0 opacity-0">${escapeHtml(dateShort)}</span>
                <div>
                  ${matchedLines.map((line) => `<p class="text-sm text-[var(--color-muted)] font-mono break-all">${escapeHtml(line)}</p>`).join('')}
                </div>
              </div>
            `
            : '';

          return `
            <li>
              <div class="flex gap-4 items-baseline">
                <time class="text-sm text-[var(--color-muted)] font-mono shrink-0" datetime="${escapeHtml(dateISO)}">
                  ${escapeHtml(dateShort)}
                </time>
                <a href="${escapeHtml(link)}" class="hover:text-[var(--color-accent)] transition-colors truncate">
                  ${escapeHtml(title)}
                </a>
              </div>
              ${snippetHtml}
            </li>
          `;
        }).join('');

        return `
          <div class="mb-8">
            <h2 class="text-xl font-semibold mb-4 text-[var(--color-muted)]">${escapeHtml(year)}</h2>
            <ul class="space-y-2">
              ${itemsHtml}
            </ul>
          </div>
        `;
      }).join('');

      resultsEl.innerHTML = groupHtml;
    };

    const showGroups = () => {
      if (groupsEl) groupsEl.hidden = false;
      resultsEl.hidden = true;
    };
    const showResults = () => {
      if (groupsEl) groupsEl.hidden = true;
      resultsEl.hidden = false;
    };

    // Make search accessible
    searchInput.setAttribute('aria-label', 'Search posts');
    searchInput.setAttribute('role', 'search');

    const loadScriptOnce = (src) => {
      const existing = document.querySelector(`script[src="${src}"]`);
      if (existing) {
        if (window.Fuse) return Promise.resolve();
        return new Promise((resolve, reject) => {
          existing.addEventListener('load', () => resolve(), { once: true });
          existing.addEventListener('error', () => reject(new Error(`Failed to load ${src}`)), { once: true });
        });
      }
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.defer = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(s);
      });
    };

    const loadFuseCtor = async () => {
      if (window.Fuse) return window.Fuse;
      try {
        await loadScriptOnce(fuseSrc);
      } catch (e) {
        return null;
      }
      return window.Fuse || null;
    };

    const initFuse = async () => {
      if (fuseInstance) return fuseInstance;
      if (!indexData) {
        try {
          const res = await fetch(indexUrl);
          if (!res.ok) return null;
          indexData = await res.json();
        } catch (e) {
          // Fail silently to avoid breaking page
          return null;
        }
      }
      if (!Array.isArray(indexData)) return null;
      const Fuse = await loadFuseCtor();
      if (!Fuse) return null;
      const options = {
        includeScore: true,
        includeMatches: true,
        findAllMatches: true,
        ignoreLocation: true,
        minMatchCharLength: 2,
        threshold: 0.3,
        keys: [
          { name: 'title', weight: 2 },
          { name: 'summary', weight: 1 },
          { name: 'tags', weight: 0.5 },
          { name: 'categories', weight: 0.5 },
          { name: 'content', weight: 0.25 }
        ]
      };
      fuseInstance = new Fuse(indexData, options);
      return fuseInstance;
    };

    searchInput.addEventListener('focus', () => {
      void initFuse();
    }, { once: true });

    searchInput.addEventListener('input', async (ev) => {
      const q = (ev.target.value || '').trim();
      if (q.length === 0) {
        showGroups();
        return;
      }
      const fuse = await initFuse();
      if (!fuse) return;
      const results = fuse.search(q).slice(0, 50);
      renderResults(results, q);
      showResults();
    });

    // If homepage hides groups, ensure initial state shows results hidden
    if (!groupsEl) {
      resultsEl.hidden = true;
    }
  }

  // PhotoSwipe lightbox for images in article content (lazy-loaded)
  (() => {
    const article = document.querySelector('article.content');
    if (!article) return;
    if (!article.querySelector('a[data-pswp-width], a.lightbox-image, img')) return;

    const photoswipeCss = 'https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe.css';
    const photoswipeLightboxSrc = 'https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe-lightbox.esm.min.js';
    const photoswipeModuleSrc = 'https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe.esm.min.js';

    const ensureStylesheet = (href) => {
      if (document.querySelector(`link[rel="stylesheet"][href="${href}"]`)) return;
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = href;
      document.head.appendChild(link);
    };

    // Helper to reliably get intrinsic dimensions; falls back to probing the src
    const getImageDimensions = (src, imgEl) => new Promise((resolve) => {
      const w = (imgEl && imgEl.naturalWidth) || 0;
      const h = (imgEl && imgEl.naturalHeight) || 0;
      if (w > 0 && h > 0) {
        resolve({ width: w, height: h });
        return;
      }
      const probe = new Image();
      probe.onload = () => {
        resolve({
          width: probe.naturalWidth || 1600,
          height: probe.naturalHeight || 900
        });
      };
      probe.onerror = () => resolve({ width: 1600, height: 900 });
      probe.src = src;
    });

    let initPromise = null;
    const init = async () => {
      if (initPromise) return initPromise;
      initPromise = (async () => {
        try {
          ensureStylesheet(photoswipeCss);
          const { default: PhotoSwipeLightbox } = await import(photoswipeLightboxSrc);
          const pswpModule = () => import(photoswipeModuleSrc);

          // Primary lightbox for images with data-pswp-width attributes
          const lightbox = new PhotoSwipeLightbox({
            gallery: 'article.content',
            children: 'a[data-pswp-width]',
            wheelToZoom: true,
            pswpModule
          });
          lightbox.init();

          const manualLb = new PhotoSwipeLightbox({ wheelToZoom: true, pswpModule });
          manualLb.init();

          // Handle lightbox-image anchors missing intrinsic dimensions
          const lightboxAnchors = Array.from(article.querySelectorAll('a.lightbox-image:not([data-pswp-width])'))
            .map(a => ({ a, img: a.querySelector('img') }))
            .filter(x => x.img);

          lightboxAnchors.forEach(({ a, img }) => {
            a.style.cursor = 'zoom-in';
            a.addEventListener('click', async (e) => {
              e.preventDefault();
              const src = a.getAttribute('href');
              const dims = await getImageDimensions(src, img);
              manualLb.loadAndOpen(0, [{ src, width: dims.width, height: dims.height, alt: img.alt || '' }]);
            });
          });

          // Fallback for images not wrapped by any anchor
          const orphanImgs = Array.from(article.querySelectorAll('img:not(a img)'));
          orphanImgs.forEach((img) => {
            img.style.cursor = 'zoom-in';
            img.addEventListener('click', async () => {
              const src = img.currentSrc || img.src;
              const dims = await getImageDimensions(src, img);
              manualLb.loadAndOpen(0, [{ src, width: dims.width, height: dims.height, alt: img.alt || '' }]);
            });
          });
        } catch (e) {
          // no-op if CDN blocked
        }
      })();
      return initPromise;
    };

    if (typeof window.requestIdleCallback === 'function') {
      window.requestIdleCallback(() => { void init(); }, { timeout: 2000 });
    } else {
      setTimeout(() => { void init(); }, 300);
    }
  })();

  // Copy-to-clipboard for code blocks
  document.addEventListener('click', async (ev) => {
    const btn = ev.target.closest('[data-copy-code]');
    if (!btn) return;
    const wrapper = btn.closest('.codeblock');
    if (!wrapper) return;
    const pre = wrapper.querySelector('.highlight pre');
    if (!pre) return;
    try {
      const text = pre.textContent || '';
      await navigator.clipboard.writeText(text);
      const original = btn.textContent;
      btn.textContent = 'Copied';
      setTimeout(() => { btn.textContent = original; }, 1200);
    } catch (e) {
      // ignore
    }
  });

  // Word wrap toggle for code blocks
  document.addEventListener('click', (ev) => {
    const btn = ev.target.closest('[data-wrap-toggle]');
    if (!btn) return;
    const wrapper = btn.closest('.codeblock');
    if (!wrapper) return;
    const isWrapped = wrapper.classList.toggle('wrapped');
    btn.textContent = isWrapped ? 'Nowrap' : 'Wrap';
  });
  
  // Theme toggle
  const themeBtn = document.querySelector('[data-theme-toggle]');
  if (themeBtn) {
    const root = document.documentElement;
    const applyTheme = (theme) => {
      root.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
      themeBtn.setAttribute('aria-label', theme === 'dark' ? 'Switch to light theme' : 'Switch to dark theme');
    };
    const current = root.getAttribute('data-theme') || (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    applyTheme(current);
    themeBtn.addEventListener('click', () => {
      const next = root.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      applyTheme(next);
      // Notify listeners (e.g., mermaid re-render)
      try { window.dispatchEvent(new Event('themechange')); } catch (_) {}
    });
  }
});
