console.log('This site was generated by Hugo.');

document.addEventListener('DOMContentLoaded', () => {
  const upvoteContainers = Array.from(document.querySelectorAll('[data-upvote]'));
  if (upvoteContainers.length) {
    upvoteContainers.forEach((container) => {
      const slug = container.getAttribute('data-slug');
      const endpoint = container.getAttribute('data-endpoint');
      const infoEndpoint = container.getAttribute('data-info-endpoint');
      const upvotedTitle = container.getAttribute('data-upvoted-title') || '';
      const form = container.querySelector('form');
      const button = container.querySelector('.upvote-button');
      const countEl = container.querySelector('.upvote-count');
      if (!slug || !endpoint || !infoEndpoint || !form || !button || !countEl) {
        return;
      }

      const updateState = ({ upvote_count, upvoted }) => {
        if (typeof upvote_count === 'number') {
          countEl.textContent = upvote_count.toString();
        }
        if (upvoted) {
          button.disabled = true;
          button.classList.add('upvote-button--active');
          if (upvotedTitle) button.title = upvotedTitle;
        }
      };

      fetch(`${infoEndpoint}?slug=${encodeURIComponent(slug)}`, { credentials: 'include' })
        .then((resp) => resp.ok ? resp.json() : null)
        .then((data) => {
          if (!data) return;
          updateState(data);
        })
        .catch(() => {});

      form.addEventListener('submit', (e) => {
        e.preventDefault();
        if (button.disabled) return;

        fetch(endpoint, {
          method: 'POST',
          body: new FormData(form),
          credentials: 'include',
        })
          .then((resp) => resp.ok ? resp.json() : Promise.reject(new Error('Upvote failed')))
          .then((data) => {
            // Success UI: disable + salmon + increment.
            button.disabled = true;
            button.classList.add('upvote-button--active');
            if (upvotedTitle) button.title = upvotedTitle;

            const current = parseInt((countEl.textContent || '').trim(), 10);
            const baseline = Number.isFinite(current) ? current : 0;
            const next = (data && typeof data.upvote_count === 'number') ? data.upvote_count : (baseline + 1);
            countEl.textContent = String(next);
          })
          .catch(() => {});
      });
    });
  }
  // Mobile nav toggle
  const navToggleBtn = document.querySelector('[data-nav-toggle]');
  const navEl = document.querySelector('[data-nav]');
  if (navToggleBtn && navEl) {
    navToggleBtn.addEventListener('click', () => {
      const open = navEl.classList.toggle('is-open');
      navToggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
    });
  }

  const toc = document.querySelector('.toc-dropdown');
  if (toc) {
    toc.addEventListener('click', (e) => {
      const target = e.target;
      if (target && target.tagName === 'A') {
        toc.open = false;
      }
    });
  }

  // Archive search wiring
  const searchInput = document.getElementById('archive-search');
  const groupsEl = document.getElementById('archive-groups');
  const resultsEl = document.getElementById('archive-results');
  if (searchInput && resultsEl) {
    let fuseInstance = null;
    let indexData = null;
    const indexUrl = searchInput.getAttribute('data-index-url') || '/index.json';
    const noResultsText = searchInput.getAttribute('data-no-results') || 'No results';
    const fuseSrc = 'https://cdn.jsdelivr.net/npm/fuse.js@7.0.0';

    const escapeHtml = (value) => String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

    const collectMatchedLines = ({ item, matches }, query) => {
      const lines = new Set();

      const safeQuery = String(query || '').trim().toLowerCase();
      const queryTerms = safeQuery.length ? safeQuery.split(/\s+/).filter(Boolean) : [];

      const normalizeSnippetLine = (line) => {
        let out = String(line || '').trim();
        if (!out) return '';
        if (out === '```') return '';
        out = out
          .replace(/^#{1,6}\s+/, '')
          .replace(/^\s*([-*+]|\d+\.)\s+/, '')
          .replace(/^>\s+/, '')
          .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1')
          .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
          .replace(/`([^`]+)`/g, '$1')
          .trim();
        return out;
      };

      const content = typeof item.content === 'string' ? item.content.replace(/\r\n/g, '\n') : '';
      const summary = typeof item.summary === 'string' ? item.summary.replace(/\r\n/g, '\n') : '';

      const matchArr = Array.isArray(matches) ? matches : [];
      const contentMatches = matchArr.filter((m) => m && m.key === 'content' && Array.isArray(m.indices));

      contentMatches.forEach((m) => {
        const value = typeof m.value === 'string' ? m.value.replace(/\r\n/g, '\n') : content;
        if (!value) return;
        m.indices.forEach((pair) => {
          if (!Array.isArray(pair) || pair.length < 2) return;
          const startIndex = pair[0];
          const endIndex = pair[1];
          if (typeof startIndex !== 'number' || typeof endIndex !== 'number') return;
          const lineStartIdx = value.lastIndexOf('\n', startIndex);
          const lineStart = lineStartIdx === -1 ? 0 : lineStartIdx + 1;
          const lineEndIdx = value.indexOf('\n', endIndex + 1);
          const lineEnd = lineEndIdx === -1 ? value.length : lineEndIdx;
          const line = normalizeSnippetLine(value.slice(lineStart, lineEnd));
          if (line) lines.add(line);
        });
      });

      if (lines.size === 0 && content && queryTerms.length) {
        content.split(/\n+/).forEach((line) => {
          const trimmed = normalizeSnippetLine(line);
          if (!trimmed) return;
          const lower = trimmed.toLowerCase();
          if (queryTerms.every((term) => lower.includes(term))) {
            lines.add(trimmed);
          }
        });
      }

      if (lines.size === 0 && summary && queryTerms.length) {
        summary.split(/\n+/).forEach((line) => {
          const trimmed = normalizeSnippetLine(line);
          if (!trimmed) return;
          const lower = trimmed.toLowerCase();
          if (queryTerms.every((term) => lower.includes(term))) {
            lines.add(trimmed);
          }
        });
      }

      return Array.from(lines);
    };

    const renderResults = (items, query) => {
      if (!Array.isArray(items)) return;
      if (items.length === 0) {
        resultsEl.innerHTML = `<p class="text-[var(--color-muted)]">${escapeHtml(noResultsText)}</p>`;
        return;
      }

      const normalized = items.map((r) => ({
        item: r && r.item ? r.item : r,
        matches: r && Array.isArray(r.matches) ? r.matches : []
      })).filter((x) => x.item);

      const grouped = new Map();
      normalized.forEach((r) => {
        const year = r.item.year || (typeof r.item.dateISO === 'string' ? r.item.dateISO.slice(0, 4) : '');
        if (!grouped.has(year)) grouped.set(year, []);
        grouped.get(year).push(r);
      });

      const years = Array.from(grouped.keys())
        .filter(Boolean)
        .sort((a, b) => (Number(b) || 0) - (Number(a) || 0));

      const groupHtml = years.map((year) => {
        const groupItems = grouped.get(year) || [];
        groupItems.sort((a, b) => String(b.item.dateISO || '').localeCompare(String(a.item.dateISO || '')));

        const itemsHtml = groupItems.map((r) => {
          const title = r.item.title || '';
          const dateShort = r.item.dateShort || r.item.date || '';
          const dateISO = r.item.dateISO || '';
          const link = r.item.permalink || '#';
          const matchedLines = collectMatchedLines(r, query);

          const snippetHtml = matchedLines.length
            ? `
              <div class="flex gap-4 mt-1">
                <span aria-hidden="true" class="text-sm text-[var(--color-muted)] font-mono shrink-0 opacity-0">${escapeHtml(dateShort)}</span>
                <div>
                  ${matchedLines.map((line) => `<p class="text-sm text-[var(--color-muted)] font-mono break-all">${escapeHtml(line)}</p>`).join('')}
                </div>
              </div>
            `
            : '';

          return `
            <li>
              <div class="flex gap-4 items-baseline">
                <time class="text-sm text-[var(--color-muted)] font-mono shrink-0" datetime="${escapeHtml(dateISO)}">
                  ${escapeHtml(dateShort)}
                </time>
                <a href="${escapeHtml(link)}" class="hover:text-[var(--color-accent)] transition-colors truncate">
                  ${escapeHtml(title)}
                </a>
              </div>
              ${snippetHtml}
            </li>
          `;
        }).join('');

        return `
          <div class="mb-8">
            <h2 class="text-xl font-semibold mb-4 text-[var(--color-muted)]">${escapeHtml(year)}</h2>
            <ul class="space-y-2">
              ${itemsHtml}
            </ul>
          </div>
        `;
      }).join('');

      resultsEl.innerHTML = groupHtml;
    };

    const showGroups = () => {
      if (groupsEl) groupsEl.hidden = false;
      resultsEl.hidden = true;
    };
    const showResults = () => {
      if (groupsEl) groupsEl.hidden = true;
      resultsEl.hidden = false;
    };

    // Make search accessible
    searchInput.setAttribute('role', 'search');

    const loadScriptOnce = (src) => {
      const existing = document.querySelector(`script[src="${src}"]`);
      if (existing) {
        if (window.Fuse) return Promise.resolve();
        return new Promise((resolve, reject) => {
          existing.addEventListener('load', () => resolve(), { once: true });
          existing.addEventListener('error', () => reject(new Error(`Failed to load ${src}`)), { once: true });
        });
      }
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.defer = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(s);
      });
    };

    const loadFuseCtor = async () => {
      if (window.Fuse) return window.Fuse;
      try {
        await loadScriptOnce(fuseSrc);
      } catch (e) {
        return null;
      }
      return window.Fuse || null;
    };

    const initFuse = async () => {
      if (fuseInstance) return fuseInstance;
      if (!indexData) {
        try {
          const res = await fetch(indexUrl);
          if (!res.ok) return null;
          indexData = await res.json();
        } catch (e) {
          // Fail silently to avoid breaking page
          return null;
        }
      }
      if (!Array.isArray(indexData)) return null;
      const Fuse = await loadFuseCtor();
      if (!Fuse) return null;
      const options = {
        includeScore: true,
        includeMatches: true,
        findAllMatches: true,
        ignoreLocation: true,
        minMatchCharLength: 2,
        threshold: 0.3,
        keys: [
          { name: 'title', weight: 2 },
          { name: 'summary', weight: 1 },
          { name: 'tags', weight: 0.5 },
          { name: 'categories', weight: 0.5 },
          { name: 'content', weight: 0.25 }
        ]
      };
      fuseInstance = new Fuse(indexData, options);
      return fuseInstance;
    };

    searchInput.addEventListener('focus', () => {
      void initFuse();
    }, { once: true });

    searchInput.addEventListener('input', async (ev) => {
      const q = (ev.target.value || '').trim();
      if (q.length === 0) {
        showGroups();
        return;
      }
      const fuse = await initFuse();
      if (!fuse) return;
      const results = fuse.search(q).slice(0, 50);
      renderResults(results, q);
      showResults();
    });

    // If homepage hides groups, ensure initial state shows results hidden
    if (!groupsEl) {
      resultsEl.hidden = true;
    }
  }

  // PhotoSwipe lightbox for images in article content (lazy-loaded)
  (() => {
    // Bear Blog pages render content directly inside <main>; keep lightbox wiring
    // scoped to that container (no special article wrapper).
    const container = document.querySelector('main');
    if (!container) return;
    if (!container.querySelector('a[data-pswp-width], a.lightbox-image, img')) return;

    const photoswipeCss = 'https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe.css';
    const photoswipeLightboxSrc = 'https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe-lightbox.esm.min.js';
    const photoswipeModuleSrc = 'https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe.esm.min.js';

    const ensureStylesheet = (href) => {
      if (document.querySelector(`link[rel="stylesheet"][href="${href}"]`)) return;
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = href;
      document.head.appendChild(link);
    };

    // Helper to reliably get intrinsic dimensions; falls back to probing the src
    const getImageDimensions = (src, imgEl) => new Promise((resolve) => {
      const w = (imgEl && imgEl.naturalWidth) || 0;
      const h = (imgEl && imgEl.naturalHeight) || 0;
      if (w > 0 && h > 0) {
        resolve({ width: w, height: h });
        return;
      }
      const probe = new Image();
      probe.onload = () => {
        resolve({
          width: probe.naturalWidth || 1600,
          height: probe.naturalHeight || 900
        });
      };
      probe.onerror = () => resolve({ width: 1600, height: 900 });
      probe.src = src;
    });

    let initPromise = null;
    const init = async () => {
      if (initPromise) return initPromise;
      initPromise = (async () => {
        try {
          ensureStylesheet(photoswipeCss);
          const { default: PhotoSwipeLightbox } = await import(photoswipeLightboxSrc);
          const pswpModule = () => import(photoswipeModuleSrc);

          // Primary lightbox for images with data-pswp-width attributes
          const lightbox = new PhotoSwipeLightbox({
            gallery: 'main',
            children: 'a[data-pswp-width]',
            wheelToZoom: true,
            pswpModule
          });
          lightbox.init();

          const manualLb = new PhotoSwipeLightbox({ wheelToZoom: true, pswpModule });
          manualLb.init();

          // Handle lightbox-image anchors missing intrinsic dimensions
          const lightboxAnchors = Array.from(container.querySelectorAll('a.lightbox-image:not([data-pswp-width])'))
            .map(a => ({ a, img: a.querySelector('img') }))
            .filter(x => x.img);

          lightboxAnchors.forEach(({ a, img }) => {
            a.style.cursor = 'zoom-in';
            a.addEventListener('click', async (e) => {
              e.preventDefault();
              const src = a.getAttribute('href');
              const dims = await getImageDimensions(src, img);
              manualLb.loadAndOpen(0, [{ src, width: dims.width, height: dims.height, alt: img.alt || '' }]);
            });
          });

          // Fallback for images not wrapped by any anchor
          const orphanImgs = Array.from(container.querySelectorAll('img:not(a img)'));
          orphanImgs.forEach((img) => {
            img.style.cursor = 'zoom-in';
            img.addEventListener('click', async () => {
              const src = img.currentSrc || img.src;
              const dims = await getImageDimensions(src, img);
              manualLb.loadAndOpen(0, [{ src, width: dims.width, height: dims.height, alt: img.alt || '' }]);
            });
          });
        } catch (e) {
          // no-op if CDN blocked
        }
      })();
      return initPromise;
    };

    if (typeof window.requestIdleCallback === 'function') {
      window.requestIdleCallback(() => { void init(); }, { timeout: 2000 });
    } else {
      setTimeout(() => { void init(); }, 300);
    }
  })();

  // Copy-to-clipboard for code blocks
  document.addEventListener('click', async (ev) => {
    const btn = ev.target.closest('[data-copy-code]');
    if (!btn) return;
    const wrapper = btn.closest('.codeblock');
    if (!wrapper) return;
    const pre = wrapper.querySelector('.highlight pre');
    if (!pre) return;
    try {
      const text = pre.textContent || '';
      await navigator.clipboard.writeText(text);
      const copiedText = btn.getAttribute('data-copied-text') || 'COPIED';
      const copiedTitle = btn.getAttribute('data-copied-title') || copiedText;

      // Icon-only buttons should not have their DOM replaced with text.
      if (btn.hasAttribute('data-icon-button')) {
        const originalTitle = btn.getAttribute('data-original-title') || btn.title || '';
        if (!btn.hasAttribute('data-original-title')) btn.setAttribute('data-original-title', originalTitle);
        btn.classList.add('is-copied');
        btn.title = copiedTitle;
        setTimeout(() => {
          btn.classList.remove('is-copied');
          btn.title = btn.getAttribute('data-original-title') || originalTitle;
        }, 1200);
      } else {
        const original = btn.textContent;
        btn.textContent = copiedText;
        setTimeout(() => { btn.textContent = original; }, 1200);
      }
    } catch (e) {
      // ignore
    }
  });

  // Word wrap toggle for code blocks
  document.addEventListener('click', (ev) => {
    const btn = ev.target.closest('[data-wrap-toggle]');
    if (!btn) return;
    const wrapper = btn.closest('.codeblock');
    if (!wrapper) return;
    const isWrapped = wrapper.classList.toggle('wrapped');
    btn.setAttribute('aria-pressed', isWrapped ? 'true' : 'false');

    const wrapText = btn.getAttribute('data-wrap-text') || 'WRAP';
    const nowrapText = btn.getAttribute('data-nowrap-text') || 'NOWRAP';
    const wrapTitle = btn.getAttribute('data-wrap-title') || wrapText;
    const nowrapTitle = btn.getAttribute('data-nowrap-title') || nowrapText;

    if (btn.hasAttribute('data-icon-button')) {
      btn.classList.toggle('is-active', isWrapped);
      btn.title = isWrapped ? nowrapTitle : wrapTitle;
    } else {
      btn.textContent = isWrapped ? nowrapText : wrapText;
    }
  });
  
  // Theme toggle
  const themeBtn = document.querySelector('[data-theme-toggle]');
  if (themeBtn) {
    const root = document.documentElement;
    const applyTheme = (theme) => {
      root.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
    };
    const current = root.getAttribute('data-theme') || (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    applyTheme(current);
    themeBtn.addEventListener('click', () => {
      const next = root.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      applyTheme(next);
      // Notify listeners (e.g., mermaid re-render)
      try { window.dispatchEvent(new Event('themechange')); } catch (_) {}
    });
  }

  // Bear Blog-style tag filtering on post list pages (`?q=tag1,tag2`)
  (() => {
    const tagCloud = document.getElementById('tags');
    const postList = document.querySelector('ul.blog-posts[data-tag-filter]');
    const filtersContainer = document.getElementById('tag-filters');
    if (!tagCloud || !postList) return;

    // Optional: Fuse-powered search (the theme used to have this; keep it minimal & Bear-like).
    const searchInput = document.getElementById('blog-search');
    const indexUrl = (searchInput && searchInput.getAttribute('data-index-url')) || '/index.json';
    const noResultsText = (searchInput && searchInput.getAttribute('data-no-results')) || 'No results';
    const fuseSrc = 'https://cdn.jsdelivr.net/npm/fuse.js@7.0.0';
    let fuseInstance = null;
    let indexData = null;

    const base = tagCloud.getAttribute('data-base') || window.location.pathname;
    const filteringFor = tagCloud.getAttribute('data-filtering-for') || 'Filtering for:';
    const removeAllLabel = tagCloud.getAttribute('data-remove-all') || 'Remove all filters';
    const removeTagTitle = tagCloud.getAttribute('data-remove-tag') || 'Remove tag';

    const escapeHtml = (value) => String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

    const decodeTags = () => {
      const b64 = tagCloud.getAttribute('data-tags') || '';
      if (!b64) return [];
      try {
        const json = atob(b64);
        const arr = JSON.parse(json);
        return Array.isArray(arr) ? arr : [];
      } catch (_) {
        return [];
      }
    };

    const normalizeTag = (t) => String(t || '')
      .trim()
      .toLowerCase()
      .replace(/\s+/g, '-');

    const allTags = decodeTags()
      .map(normalizeTag)
      .filter(Boolean);

    const params = new URLSearchParams(window.location.search);
    const q = (params.get('q') || '').trim();
    const activeTags = q
      .split(',')
      .map(normalizeTag)
      .filter(Boolean);

    const items = Array.from(postList.querySelectorAll('li'));

    const parseItemTags = (li) => {
      const el = li.querySelector('[data-tags]');
      const raw = el ? (el.textContent || '') : '';
      return raw.split('|').map(normalizeTag).filter(Boolean);
    };

    const hasAll = (tags, required) => required.every((t) => tags.includes(t));

    const ensureFuse = async () => {
      if (fuseInstance) return fuseInstance;
      if (!searchInput) return null;
      if (!indexData) {
        try {
          const res = await fetch(indexUrl);
          if (!res.ok) return null;
          indexData = await res.json();
        } catch (_) {
          return null;
        }
      }
      if (!Array.isArray(indexData)) return null;
      if (!window.Fuse) {
        await new Promise((resolve, reject) => {
          const existing = document.querySelector(`script[src="${fuseSrc}"]`);
          if (existing) return resolve();
          const s = document.createElement('script');
          s.src = fuseSrc;
          s.defer = true;
          s.onload = () => resolve();
          s.onerror = () => reject(new Error('Failed to load Fuse'));
          document.head.appendChild(s);
        }).catch(() => null);
      }
      if (!window.Fuse) return null;
      const options = {
        includeScore: true,
        threshold: 0.3,
        ignoreLocation: true,
        minMatchCharLength: 2,
        keys: [
          { name: 'title', weight: 2 },
          { name: 'summary', weight: 1 },
          { name: 'tags', weight: 0.75 },
          { name: 'content', weight: 0.25 }
        ]
      };
      fuseInstance = new window.Fuse(indexData, options);
      return fuseInstance;
    };

    const normalizeHref = (href) => {
      try {
        // Make absolute → pathname, keep relative untouched.
        const u = new URL(href, window.location.origin);
        return u.pathname;
      } catch (_) {
        return href;
      }
    };

    const applyVisibility = async () => {
      const searchQuery = searchInput ? String(searchInput.value || '').trim() : '';
      let searchMatches = null;

      if (searchQuery) {
        const fuse = await ensureFuse();
        if (fuse) {
          const results = fuse.search(searchQuery).slice(0, 100);
          searchMatches = new Set(results.map((r) => normalizeHref((r.item && r.item.permalink) || '')));
        } else {
          // If Fuse can't load, degrade to simple title substring match.
          searchMatches = new Set();
          if (indexData && Array.isArray(indexData)) {
            indexData.forEach((item) => {
              const title = String(item && item.title ? item.title : '').toLowerCase();
              if (title.includes(searchQuery.toLowerCase())) {
                searchMatches.add(normalizeHref(item.permalink || ''));
              }
            });
          }
        }
      }

      const visibleTags = [];
      let visibleCount = 0;

      items.forEach((li) => {
        const tags = parseItemTags(li);
        const passesTags = activeTags.length ? hasAll(tags, activeTags) : true;
        const a = li.querySelector('a[href]');
        const href = a ? normalizeHref(a.getAttribute('href') || '') : '';
        const passesSearch = !searchMatches || (href && searchMatches.has(href));
        const show = passesTags && passesSearch;
        li.style.display = show ? '' : 'none';
        if (show) {
          visibleCount += 1;
          visibleTags.push(tags);
        }
      });

      // Minimal empty-state (Bear-ish).
      if (searchInput) {
        let emptyP = document.getElementById('blog-search-empty');
        if (!emptyP) {
          emptyP = document.createElement('p');
          emptyP.id = 'blog-search-empty';
          emptyP.innerHTML = `<small>${escapeHtml(noResultsText)}</small>`;
          postList.parentElement && postList.parentElement.insertBefore(emptyP, postList);
        }
        emptyP.style.display = (searchQuery && visibleCount === 0) ? '' : 'none';
      }

      return visibleTags;
    };

    const renderFilters = () => {
      if (!filtersContainer) return;
      if (activeTags.length) {
        const spans = activeTags.map((tag) => {
          const remaining = activeTags.filter((t) => t !== tag);
          const href = remaining.length ? `${base}?q=${encodeURIComponent(remaining.join(','))}` : base;
          return `<span class="tag">#${escapeHtml(tag)} <a rel="nofollow" href="${href}" title="${escapeHtml(removeTagTitle)}" style="text-decoration:none;">✕</a></span>`;
        }).join(' ');
        filtersContainer.innerHTML = `<h3 style="margin-bottom:0">${escapeHtml(filteringFor)} ${spans}</h3><small><a rel="nofollow" href="${base}">${escapeHtml(removeAllLabel)}</a></small>`;
      } else {
        filtersContainer.innerHTML = '';
      }
    };

    // Match Bear's server-side `available_tags` logic, but computed client-side from the rendered post list:
    // available tags = union(tags for posts that match activeTags).
    const computeAvailableTagsForCloud = () => {
      const available = new Set();
      items.forEach((li) => {
        const tags = parseItemTags(li);
        const passesTags = activeTags.length ? hasAll(tags, activeTags) : true;
        if (passesTags) tags.forEach((t) => available.add(t));
      });
      return available;
    };

    const renderTagCloud = () => {
      const availableTags = computeAvailableTagsForCloud();
      const tagsToShow = allTags.filter((t) => !activeTags.includes(t) && availableTags.has(t));

      // Render tag cloud links (like Bear Blog: append links + spaces)
      tagCloud.innerHTML = '';

      // Keep hidden #potofhoney link for Bear compatibility.
      const honey = document.createElement('a');
      honey.rel = 'nofollow';
      honey.href = `${base}?q=pot-of-honey`;
      honey.textContent = '#potofhoney';
      honey.style.display = 'none';
      tagCloud.appendChild(honey);
      tagCloud.appendChild(document.createTextNode(' '));

      tagsToShow.forEach((tag) => {
        const a = document.createElement('a');
        const next = activeTags.length ? `${activeTags.join(',')},${tag}` : tag;
        a.href = `${base}?q=${encodeURIComponent(next)}`;
        a.textContent = `#${tag}`;
        a.rel = 'nofollow';
        tagCloud.appendChild(a);
        tagCloud.appendChild(document.createTextNode(' '));
      });
    };

    // Initial render.
    renderFilters();
    renderTagCloud();
    // eslint-disable-next-line no-void
    void applyVisibility();

    if (searchInput) {
      searchInput.addEventListener('focus', () => { void ensureFuse(); }, { once: true });
      searchInput.addEventListener('input', () => { void applyVisibility(); });
    }
  })();

  // Home: populate "most popular posts" using upvote counts.
  // This mirrors the spirit of Herman's homepage sections while keeping the markup minimal:
  // https://herman.bearblog.dev/
  (() => {
    const list = document.getElementById('home-popular-posts');
    if (!list) return;

    const limit = parseInt(list.getAttribute('data-limit') || '5', 10) || 5;
    const indexUrl = list.getAttribute('data-index-url') || '/index.json';
    const infoEndpoint = list.getAttribute('data-info-endpoint') || '';
    if (!infoEndpoint) return;

    const candidateLimit = parseInt(list.getAttribute('data-candidate-limit') || '50', 10) || 50;

    const normalizePath = (href) => {
      try {
        const u = new URL(href, window.location.origin);
        return u.pathname;
      } catch (_) {
        return String(href || '');
      }
    };

    const toSlug = (permalink) => {
      const path = normalizePath(permalink);
      return path.replace(/\/$/, '') || path;
    };

    const loadIndex = async () => {
      const res = await fetch(indexUrl);
      if (!res.ok) return [];
      const data = await res.json();
      return Array.isArray(data) ? data : [];
    };

    const run = async () => {
      const items = await loadIndex();
      if (!items.length) return;

      const dateKey = (iso) => {
        const m = /^(\d{4})-(\d{2})-(\d{2})/.exec(String(iso || ''));
        if (!m) return 0;
        return (Number(m[1]) * 10000) + (Number(m[2]) * 100) + Number(m[3]);
      };

      const sortedByDate = items
        .filter((it) => it && it.permalink && it.title)
        .slice()
        .sort((a, b) => dateKey(b.dateISO) - dateKey(a.dateISO));

      const candidates = sortedByDate.slice(0, Math.max(1, candidateLimit));

      const fetchCount = async (slug) => {
        try {
          const res = await fetch(`${infoEndpoint}?slug=${encodeURIComponent(slug)}`, { credentials: 'include' });
          if (!res.ok) return 0;
          const data = await res.json();
          return (data && typeof data.upvote_count === 'number') ? data.upvote_count : 0;
        } catch (_) {
          return 0;
        }
      };

      // Concurrency-limited fetch to avoid hammering the endpoint.
      const concurrency = 8;
      const scored = [];
      const pool = [];
      let idx = 0;

      const worker = async () => {
        while (idx < candidates.length) {
          const item = candidates[idx++];
          if (!item) continue;
          const permalink = String(item.permalink || '');
          const title = String(item.title || '');
          if (!permalink || !title) continue;
          const slug = toSlug(permalink);
          if (!slug || !slug.startsWith('/')) continue;
          const upvotes = await fetchCount(slug);
          scored.push({ title, permalink, upvotes, dateISO: item.dateISO || '' });
        }
      };

      for (let i = 0; i < concurrency; i++) pool.push(worker());
      await Promise.all(pool);

      scored.sort((a, b) => {
        if ((b.upvotes || 0) !== (a.upvotes || 0)) return (b.upvotes || 0) - (a.upvotes || 0);
        return dateKey(b.dateISO) - dateKey(a.dateISO);
      });

      const out = scored.slice(0, limit);
      if (!out.length) return;

      list.innerHTML = '';
      out.forEach((p) => {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = p.permalink;
        a.textContent = p.title;
        li.appendChild(a);
        list.appendChild(li);
      });
    };

    // Run after load so it doesn't block first paint.
    if (typeof window.requestIdleCallback === 'function') {
      window.requestIdleCallback(() => { void run(); }, { timeout: 1500 });
    } else {
      setTimeout(() => { void run(); }, 300);
    }
  })();
});
